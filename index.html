<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Emparejador Commander</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      /* Paleta inspirada en los 5 colores de MTG */
      --c-white: #f8f5e7;
      --c-blue:  #8fc5ff;
      --c-black: #2b2b2b;
      --c-red:   #ff8b7b;
      --c-green: #7adf9b;

      --bg: #3f4248;
      --card: #ffffff;
      --accent: #8fc5ff;
      --accent-soft: #e1f0ff;
      --accent-strong: #ff8b7b;
      --text: #f5f5f5;
      --text-soft: #cccccc;
      --border: #444;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      padding: 1rem;
    }

    h1, h2, h3 {
      margin-top: 0;
    }

    h1 {
      background: linear-gradient(90deg, var(--c-white), var(--c-blue), var(--c-black), var(--c-red), var(--c-green));
      -webkit-background-clip: text;
      color: transparent;
      font-weight: 800;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
    }

    .card {
      background: var(--card);
      color: #222;
      border-radius: 14px;
      padding: 1rem 1.2rem;
      margin-bottom: 1rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      border: 1px solid rgba(0,0,0,0.4);
    }

    .flex {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .flex > div {
      flex: 1 1 250px;
      min-width: 220px;
    }

    textarea, input, select {
      width: 100%;
      padding: 0.45rem 0.6rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 0.95rem;
      resize: vertical;
      background: #f7f7fa;
    }

    label {
      font-size: 0.9rem;
      font-weight: 600;
      display: block;
      margin-bottom: 0.25rem;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.5rem 1.2rem;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.95rem;
      background: linear-gradient(135deg, var(--c-blue), var(--c-green));
      color: #111;
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
      transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
      margin-top: 0.4rem;
    }

    button:hover {
      filter: brightness(1.03);
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(0,0,0,0.25);
    }

    .btn-secondary {
      background: linear-gradient(135deg, #eeeeee, #cccccc);
      color: #222;
      margin-left: 0.3rem;
    }

    .round-card {
      border-left: 4px solid var(--accent-strong);
      margin-bottom: 0.8rem;
      padding-left: 0.8rem;
    }

    .table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.4rem;
      font-size: 0.9rem;
    }

    .table th, .table td {
      border: 1px solid #ddd;
      padding: 0.3rem 0.4rem;
      text-align: left;
    }

    .table th {
      background: linear-gradient(90deg, var(--c-white), var(--accent-soft));
      font-weight: 600;
    }

    .badge {
      display: inline-block;
      padding: 0.1rem 0.5rem;
      font-size: 0.75rem;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--accent-strong);
      font-weight: 600;
      margin-left: 0.3rem;
    }

    small {
      color: #555;
      font-size: 0.8rem;
    }

    .winner-select {
      width: 100%;
      padding: 0.25rem 0.4rem;
      font-size: 0.8rem;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #fdfdff;
    }

    .scores-note {
      font-size: 0.8rem;
      color: #555;
      margin-top: 0.25rem;
    }

    .pill {
      display: inline-block;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: #e3f2fd;
      color: #1565c0;
      font-size: 0.75rem;
      margin-left: 0.3rem;
    }

    .pill-red {
      background: #ffebee;
      color: #c62828;
    }

    .pill-green {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .boosters-summary {
      margin-top: 0.5rem;
      font-size: 0.85rem;
    }

    .warning {
      font-size: 0.85rem;
      color: #b71c1c;
      background: #ffebee;
      border-radius: 8px;
      padding: 0.4rem 0.6rem;
      margin-bottom: 0.5rem;
    }

    .round-suggestion {
      font-size: 0.8rem;
      margin-top: 0.35rem;
      color: #333;
    }

    .round-suggestion button {
      margin-top: 0.3rem;
      padding: 0.25rem 0.7rem;
      font-size: 0.8rem;
    }

    @media (max-width: 600px) {
      .table th, .table td {
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Emparejador de Mesas – MTG Commander</h1>
    <p><small>
      Ingresa la lista de jugadores y el número de rondas. Se generarán mesas de 4 jugadores,  
      intentando que <b>no se repitan demasiado los oponentes</b>. Puedes marcar ganadores/empates y llevar puntos y boosters.
    </small></p>

    <div class="card">
      <div class="flex">
        <div>
          <label for="playersInput">Jugadores <small>(uno por línea, en orden de inscripción)</small></label>
          <textarea id="playersInput" rows="8" placeholder="Ejemplo:
Alice
Bob
Carlos
Diana
Edu
Fabián
..."></textarea>
          <small>Solo se emparejarán jugadores en grupos completos de 4. Los últimos que sobren quedarán fuera y se mostrará un aviso.</small>
        </div>
        <div>
          <label for="lateInput">Mesa tardía (Ronda 1) <small>(opcional, exactamente 4 nombres)</small></label>
          <textarea id="lateInput" rows="4" placeholder="Jugadores que suelen llegar tarde (deben estar en la lista de arriba)..."></textarea>
          <small>Estos 4 jugarán juntos en la mesa tardía de la primera ronda, sin afectar al resto de mesas.</small>
        </div>
      </div>

      <div class="flex" style="margin-top:0.5rem;">
        <div>
          <label for="roundsInput">Cantidad de rondas</label>
          <input type="number" id="roundsInput" min="1" max="12" value="3" />
          <div id="roundSuggestion" class="round-suggestion"></div>
        </div>
        <div>
          <button id="generateBtn">Generar emparejamientos</button>
          <button id="resetBtn" class="btn-secondary" type="button">Resetear todo</button>
          <p class="scores-note">
            Algoritmo: solo mesas de 4 jugadores.  
            Si el número de jugadores (descontando la mesa tardía) no es múltiplo de 4, algunos quedarán fuera (los últimos de la lista).
          </p>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Rondas y mesas <span class="badge">Emparejamientos</span></h2>
      <div id="extraPlayersMessage"></div>
      <div id="pairings"></div>
    </div>

    <div class="card">
      <h2>Tabla de puntuación <span class="badge">Scores & Boosters</span></h2>
      <p class="scores-note">
        Sistema de puntos:
        <span class="pill pill-green">Victoria: 1 punto</span>
        <span class="pill pill-red">Empate o derrota: 0 puntos</span>
      </p>
      <p class="scores-note">
        Boosters:
        <span class="pill pill-green">Cada victoria = 1 booster para ese jugador</span>
        <span class="pill pill-red">Empate = 1 booster al pozo de la liga</span>
      </p>
      <div class="boosters-summary">
        Booster en pozo de la liga: <strong id="leaguePot">0</strong>
      </div>
      <div id="scores"></div>
    </div>
  </div>

  <script>
    // --------------- ESTADO GLOBAL & PERSISTENCIA ---------------

    let globalRounds = [];   // [ [ [playersMesa1], [playersMesa2], ... ], ... ]
    let globalWinners = [];  // misma forma, guarda ganador o "__EMPATE__" o ""
    let lastExtras = [];     // jugadores no emparejados
    const STORAGE_KEY = 'commander_pairings_v3';

    function saveState() {
      try {
        const playersRaw = document.getElementById('playersInput').value;
        const rounds = document.getElementById('roundsInput').value;
        const lateRaw = document.getElementById('lateInput').value;
        const data = {
          playersRaw,
          rounds: parseInt(rounds, 10),
          globalRounds,
          globalWinners,
          lateRaw
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch (e) {
        console.warn('No se pudo guardar el estado:', e);
      }
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (!data || !Array.isArray(data.globalRounds)) return;

        document.getElementById('playersInput').value = data.playersRaw || '';
        if (data.rounds) {
          document.getElementById('roundsInput').value = data.rounds;
        }
        if (data.lateRaw !== undefined) {
          document.getElementById('lateInput').value = data.lateRaw;
        }

        globalRounds = data.globalRounds;
        globalWinners = data.globalWinners || globalRounds.map(r => r.map(() => ""));
        updateRoundSuggestion();
        renderPairings();
        renderScores();
      } catch (e) {
        console.warn('No se pudo cargar el estado:', e);
      }
    }

    // --------------- UTILIDADES ---------------

    function computeSuggestedRounds(numPlayers) {
      if (numPlayers <= 8) return 3;
      if (numPlayers <= 12) return 4;
      return 5; // para grupos más grandes
    }

    function updateRoundSuggestion() {
      const playersRaw = document.getElementById('playersInput').value
        .split('\n')
        .map(p => p.trim())
        .filter(p => p.length > 0);
      const uniquePlayers = Array.from(new Set(playersRaw));
      const num = uniquePlayers.length;
      const container = document.getElementById('roundSuggestion');
      container.innerHTML = '';

      if (num < 4) {
        container.textContent = 'Necesitas al menos 4 jugadores para sugerir rondas.';
        return;
      }

      const suggestion = computeSuggestedRounds(num);
      const span = document.createElement('span');
      span.textContent = `Sugerencia: ${suggestion} rondas para ${num} jugadores.`;
      container.appendChild(span);

      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = `Usar ${suggestion}`;
      btn.style.marginLeft = '0.5rem';
      btn.addEventListener('click', () => {
        document.getElementById('roundsInput').value = suggestion;
        saveState();
      });
      container.appendChild(btn);
    }

    document.getElementById('playersInput').addEventListener('input', () => {
      updateRoundSuggestion();
      saveState();
    });
    document.getElementById('roundsInput').addEventListener('input', saveState);
    document.getElementById('lateInput').addEventListener('input', saveState);

    // --------------- GENERACIÓN DE RONDAS ---------------

    document.getElementById('generateBtn').addEventListener('click', () => {
      const playersRaw = document.getElementById('playersInput').value
        .split('\n')
        .map(p => p.trim())
        .filter(p => p.length > 0);

      const rounds = parseInt(document.getElementById('roundsInput').value, 10);
      const lateRaw = document.getElementById('lateInput').value
        .split('\n')
        .map(p => p.trim())
        .filter(p => p.length > 0);

      if (playersRaw.length < 4) {
        alert('Necesitas al menos 4 jugadores.');
        return;
      }
      if (isNaN(rounds) || rounds < 1) {
        alert('Indica una cantidad válida de rondas.');
        return;
      }

      const players = Array.from(new Set(playersRaw));

      // Validar mesa tardía
      let latePlayers = [];
      if (lateRaw.length > 0) {
        const lateUnique = Array.from(new Set(lateRaw));
        if (lateUnique.length !== 4) {
          alert('La mesa tardía debe tener exactamente 4 jugadores (o dejarse vacía).');
          return;
        }
        for (const lp of lateUnique) {
          if (!players.includes(lp)) {
            alert(`El jugador "${lp}" de la mesa tardía no está en la lista principal.`);
            return;
          }
        }
        latePlayers = lateUnique;
      }

      // Calcular quiénes quedan fuera para mantener solo mesas de 4
      // 1) excluir mesa tardía de la parte "regular"
      const rest = players.filter(p => !latePlayers.includes(p));
      const remainder = rest.length % 4;
      lastExtras = [];

      if (remainder !== 0) {
        // los últimos en la lista de inscripción que no están en mesa tardía
        const restOrdered = players.filter(p => !latePlayers.includes(p)); // ya lo tenemos
        lastExtras = restOrdered.slice(restOrdered.length - remainder);
      }

      const eligiblePlayers = players.filter(p => !lastExtras.includes(p)); // incluye mesa tardía

      globalRounds = generateAllRounds(eligiblePlayers, rounds, latePlayers);
      globalWinners = globalRounds.map(round => round.map(() => ""));

      renderPairings();
      renderScores();
      saveState();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      if (!confirm('¿Seguro que quieres resetear todo? Se perderán emparejamientos, resultados y boosters.')) return;

      globalRounds = [];
      globalWinners = [];
      lastExtras = [];
      document.getElementById('playersInput').value = '';
      document.getElementById('lateInput').value = '';
      document.getElementById('roundsInput').value = 3;
      document.getElementById('pairings').innerHTML = '<p><small>Aún no se han generado rondas.</small></p>';
      document.getElementById('scores').innerHTML = '<p><small>No hay datos de puntuación.</small></p>';
      document.getElementById('leaguePot').textContent = '0';
      document.getElementById('extraPlayersMessage').innerHTML = '';
      document.getElementById('roundSuggestion').innerHTML = '';
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch (e) {}
    });

    function generateAllRounds(players, rounds, latePlayers) {
      const pairCounts = {}; // "A|B" -> veces que se enfrentaron
      const allRounds = [];
      const getKey = (a, b) => (a < b ? a + '|' + b : b + '|' + a);
      const lateSet = new Set(latePlayers || []);

      for (let r = 0; r < rounds; r++) {
        let remaining;
        const roundPods = [];

        if (r === 0 && latePlayers && latePlayers.length === 4) {
          // Mesa tardía fija
          roundPods.push([...latePlayers]);
          // actualizar pairCounts
          for (let i = 0; i < latePlayers.length; i++) {
            for (let j = i + 1; j < latePlayers.length; j++) {
              const key = getKey(latePlayers[i], latePlayers[j]);
              pairCounts[key] = (pairCounts[key] || 0) + 1;
            }
          }
          remaining = players.filter(p => !lateSet.has(p));
        } else {
          remaining = [...players];
        }

        remaining.sort(() => Math.random() - 0.5);

        while (remaining.length > 0) {
          if (remaining.length < 4) {
            // Esto no debería pasar porque ya controlamos múltiplos de 4 (sin contar mesa tardía),
            // pero por seguridad, rompemos el bucle.
            break;
          }

          const bestGroup = findBestGroup(remaining, 4, pairCounts, getKey);
          roundPods.push(bestGroup);

          // actualizar pairCounts
          for (let i = 0; i < bestGroup.length; i++) {
            for (let j = i + 1; j < bestGroup.length; j++) {
              const key = getKey(bestGroup[i], bestGroup[j]);
              pairCounts[key] = (pairCounts[key] || 0) + 1;
            }
          }

          // quitar del remaining
          for (const p of bestGroup) {
            const idx = remaining.indexOf(p);
            if (idx !== -1) remaining.splice(idx, 1);
          }
        }

        allRounds.push(roundPods);
      }

      return allRounds;
    }

    function findBestGroup(remaining, groupSize, pairCounts, getKey) {
      const indices = remaining.map((_, i) => i);
      const combos = [];
      generateCombinations(indices, groupSize, 0, [], combos);

      let best = null;
      let bestScore = Infinity;

      for (const combo of combos) {
        const group = combo.map(i => remaining[i]);
        let score = 0;
        for (let i = 0; i < group.length; i++) {
          for (let j = i + 1; j < group.length; j++) {
            const key = getKey(group[i], group[j]);
            score += (pairCounts[key] || 0);
          }
        }
        if (score < bestScore) {
          bestScore = score;
          best = group;
        }
      }

      return best || remaining.slice(0, groupSize);
    }

    function generateCombinations(arr, k, start, path, result) {
      if (path.length === k) {
        result.push([...path]);
        return;
      }
      for (let i = start; i < arr.length; i++) {
        path.push(arr[i]);
        generateCombinations(arr, k, i + 1, path, result);
        path.pop();
      }
    }

    // --------------- RENDER EMPAREJAMIENTOS ---------------

    function renderPairings() {
      const container = document.getElementById('pairings');
      const extraContainer = document.getElementById('extraPlayersMessage');
      container.innerHTML = '';
      extraContainer.innerHTML = '';

      if (lastExtras && lastExtras.length > 0) {
        const p = document.createElement('p');
        p.className = 'warning';
        p.textContent = 'Jugadores no emparejados (sobran para formar mesas de 4): ' +
                        lastExtras.join(', ') +
                        '. Agrega más jugadores o pide que algunos se retiren para que el número total (sin contar mesa tardía) sea múltiplo de 4.';
        extraContainer.appendChild(p);
      }

      if (!globalRounds.length) {
        container.innerHTML = '<p><small>Aún no se han generado rondas.</small></p>';
        return;
      }

      globalRounds.forEach((roundPods, rIndex) => {
        const roundDiv = document.createElement('div');
        roundDiv.className = 'round-card';

        const title = document.createElement('h3');
        title.textContent = `Ronda ${rIndex + 1}`;
        roundDiv.appendChild(title);

        const table = document.createElement('table');
        table.className = 'table';

        const thead = document.createElement('thead');
        thead.innerHTML = `
          <tr>
            <th>Mesa</th>
            <th>Jugadores</th>
            <th>Ganador / Empate</th>
          </tr>
        `;
        table.appendChild(thead);

        const tbody = document.createElement('tbody');

        roundPods.forEach((pod, pIndex) => {
          const tr = document.createElement('tr');

          const tdMesa = document.createElement('td');
          tdMesa.textContent = pIndex + 1;

          const tdPlayers = document.createElement('td');
          tdPlayers.textContent = pod.join(', ');

          const tdWinner = document.createElement('td');
          const select = document.createElement('select');
          select.className = 'winner-select';

          const emptyOpt = document.createElement('option');
          emptyOpt.value = '';
          emptyOpt.textContent = '— sin definir —';
          select.appendChild(emptyOpt);

          const tieOpt = document.createElement('option');
          tieOpt.value = '__EMPATE__';
          tieOpt.textContent = 'Empate entre todos';
          select.appendChild(tieOpt);

          pod.forEach(player => {
            const opt = document.createElement('option');
            opt.value = player;
            opt.textContent = player;
            select.appendChild(opt);
          });

          select.value = globalWinners[rIndex][pIndex] || '';
          select.addEventListener('change', () => {
            globalWinners[rIndex][pIndex] = select.value;
            renderScores();
            saveState();
          });

          tdWinner.appendChild(select);

          tr.appendChild(tdMesa);
          tr.appendChild(tdPlayers);
          tr.appendChild(tdWinner);

          tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        roundDiv.appendChild(table);
        container.appendChild(roundDiv);
      });
    }

    // --------------- TABLA DE PUNTUACIÓN & BOOSTERS ---------------

    function renderScores() {
      const container = document.getElementById('scores');
      container.innerHTML = '';

      let leaguePot = 0;

      if (!globalRounds.length) {
        container.innerHTML = '<p><small>No hay rondas aún.</small></p>';
        document.getElementById('leaguePot').textContent = '0';
        return;
      }

      const stats = {};

      // Inicializar
      globalRounds.forEach(roundPods => {
        roundPods.forEach(pod => {
          pod.forEach(player => {
            if (!stats[player]) {
              stats[player] = {
                player,
                wins: 0,
                draws: 0,
                losses: 0,
                games: 0,
                points: 0,
                boosters: 0
              };
            }
          });
        });
      });

      // Procesar resultados
      globalRounds.forEach((roundPods, rIndex) => {
        roundPods.forEach((pod, pIndex) => {
          const result = globalWinners[rIndex]?.[pIndex] || '';
          if (!result) return;

          if (result === '__EMPATE__') {
            pod.forEach(player => {
              stats[player].games += 1;
              stats[player].draws += 1;
            });
            leaguePot += 1;
          } else {
            pod.forEach(player => {
              stats[player].games += 1;
              if (player === result) {
                stats[player].wins += 1;
                stats[player].points += 1;   // 1 punto por victoria
                stats[player].boosters += 1; // 1 booster por victoria
              } else {
                stats[player].losses += 1;
              }
            });
          }
        });
      });

      document.getElementById('leaguePot').textContent = leaguePot.toString();

      const rows = Object.values(stats);
      rows.sort((a, b) => {
        if (b.points !== a.points) return b.points - a.points;
        if (b.wins !== a.wins) return b.wins - a.wins;
        return a.player.localeCompare(b.player);
      });

      const table = document.createElement('table');
      table.className = 'table';

      const thead = document.createElement('thead');
      thead.innerHTML = `
        <tr>
          <th>#</th>
          <th>Jugador</th>
          <th>Puntos</th>
          <th>Victorias</th>
          <th>Empates</th>
          <th>Derrotas</th>
          <th>Partidas</th>
          <th>Boosters ganados</th>
        </tr>
      `;
      table.appendChild(thead);

      const tbody = document.createElement('tbody');

      rows.forEach((st, index) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${index + 1}</td>
          <td>${st.player}</td>
          <td>${st.points}</td>
          <td>${st.wins}</td>
          <td>${st.draws}</td>
          <td>${st.losses}</td>
          <td>${st.games}</td>
          <td>${st.boosters}</td>
        `;
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      container.appendChild(table);
    }

    // --------------- INIT ---------------

    document.addEventListener('DOMContentLoaded', () => {
      loadState();
      updateRoundSuggestion();
      if (!globalRounds.length) {
        document.getElementById('pairings').innerHTML = '<p><small>Aún no se han generado rondas.</small></p>';
        document.getElementById('scores').innerHTML = '<p><small>No hay datos de puntuación.</small></p>';
      }
    });
  </script>
</body>
</html>
